# BenefitFinder - Cursor AI Rules

## Project Overview
BenefitFinder is a privacy-preserving, offline-first application for checking government benefits eligibility. All processing happens locally in the browser with no server dependencies.

## Core Principles
1. **Privacy First**: Never suggest solutions that send data to external servers or APIs
2. **Offline-First**: All features must work without internet connectivity
3. **Accessibility**: Follow WCAG 2.1 AA standards for all UI components
4. **Type Safety**: Strict TypeScript with no `any` types unless absolutely necessary
5. **Security**: Treat all user data as sensitive; use encryption for local storage
6. **Plain Language**: User-facing text should be clear and accessible to all reading levels

## Tech Stack Preferences

### Frontend
- React 18 with hooks (functional components only)
- TypeScript with strict mode enabled
- Tailwind CSS for styling (utility-first approach)
- Radix UI for accessible component primitives (always prefer over custom implementations)

### State & Data
- Zustand for global state management
- RxDB for reactive offline database operations
- Dexie for IndexedDB interactions
- Zod for runtime schema validation and type inference

### Logic & Visualization
- json-logic-js for rule evaluation (no custom rule engines)
- ReactFlow for visual flow diagrams
- Argdown for argument mapping

### Testing
- Vitest for unit tests (write tests for all new features)
- Playwright for E2E tests
- @axe-core/playwright for accessibility testing (required for UI changes)

## Code Standards

### TypeScript
- Use strict mode settings from tsconfig.json
- Prefer explicit return types for functions
- Use Zod schemas for runtime validation, derive TypeScript types from schemas
- No `any` types without explicit justification in comments
- Use discriminated unions for variant data types

### React
- Functional components only (no class components)
- Use custom hooks to extract reusable logic
- Prefer composition over prop drilling (use Zustand for shared state)
- Keep components focused and single-purpose
- Use React.memo() sparingly and only when performance issues are measured

### Styling
- Tailwind utility classes are preferred
- Use Tailwind config for theme customization (colors, spacing, etc.)
- Follow mobile-first responsive design principles
- Ensure minimum touch target size of 44x44px for interactive elements

### Accessibility
- All interactive elements must be keyboard accessible
- Use semantic HTML elements
- Include ARIA labels where semantic HTML is insufficient
- Ensure color contrast meets WCAG AA standards (4.5:1 for text)
- Test all UI changes with Playwright accessibility tests

### Security
- No external API calls or third-party services
- Use AES-GCM for encrypting sensitive data in local storage
- Sanitize any user-generated content with isomorphic-dompurify
- Validate all inputs with Zod schemas
- Never log sensitive user data

### Data & State
- Use RxDB for all persistent data storage
- Encrypt data at rest using built-in RxDB encryption
- Use Zustand for ephemeral UI state
- Keep state as close to where it's used as possible
- Use Immer for immutable state updates when needed

## Prohibited Patterns
- ‚ùå No hosted servers or cloud services
- ‚ùå No external API calls (except for optional device-to-device sync over local Wi-Fi)
- ‚ùå No analytics, tracking, or telemetry
- ‚ùå No cookies or session storage for user data
- ‚ùå No class components
- ‚ùå No inline styles (use Tailwind)
- ‚ùå No `any` types without justification
- ‚ùå No mutations of state objects (use Immer or immutable patterns)
- ‚ùå No accessibility bypasses or hacks

## File Organization
```
src/
‚îú‚îÄ‚îÄ components/       # Reusable UI components
‚îú‚îÄ‚îÄ features/        # Feature-specific modules
‚îú‚îÄ‚îÄ hooks/           # Custom React hooks
‚îú‚îÄ‚îÄ stores/          # Zustand stores
‚îú‚îÄ‚îÄ db/              # RxDB schemas and collections
‚îú‚îÄ‚îÄ rules/           # Benefit eligibility rules (JSON)
‚îú‚îÄ‚îÄ types/           # TypeScript type definitions
‚îú‚îÄ‚îÄ utils/           # Pure utility functions
‚îî‚îÄ‚îÄ __tests__/       # Component and unit tests
```

## Testing Requirements
- All new features require unit tests
- UI changes require E2E tests with Playwright
- Accessibility tests required for interactive components
- Test coverage should trend upward (no reduction without justification)
- Use testing-library queries in priority order: role > label > test-id

## Documentation
- Add JSDoc comments for exported functions and types
- Include usage examples for complex utilities or hooks
- Update README.md for significant feature additions
- Document eligibility rule schemas and examples
- **All standalone documentation markdown files must be placed in `./docs/` or relevant subdirectories within `./docs/`**
  - Examples: `./docs/ENCRYPTION.md`, `./docs/SECURITY.md`, `./docs/RULE_SCHEMA.md`
  - Organize by topic: use subdirectories for feature-specific documentation if needed
  - Never create documentation files in the project root (except README.md)

## Git Workflow
- Use conventional commit format: `type(scope): description`
- Types: feat, fix, docs, style, refactor, test, chore
- Run `npm run lint` before committing
- Ensure tests pass before pushing

## Command Execution (CRITICAL - READ FIRST)
üö® **MANDATORY: You MUST verify and navigate to the project root BEFORE executing ANY command** üö®

### Pre-Command Checklist (REQUIRED FOR EVERY COMMAND)
1. **ALWAYS start by checking the current working directory with `pwd` or `Get-Location`**
2. **If the output is NOT exactly `C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder`, you MUST run:**
   ```powershell
   cd "C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder"
   ```
3. **Only after step 2, execute your intended command**

### Rules
- **NEVER run npm, npx, node, vite, vitest, playwright, or any project command from the home directory or any other directory**
- **The FIRST command of every conversation MUST be verifying/navigating to project root**
- **Before EVERY command execution, explicitly state in your explanation: "Verifying we're in project root first"**
- **Exception**: Only remain in/navigate to subdirectories when the command explicitly requires it (e.g., testing a specific module) - but this is RARE
- The project root contains key files: `package.json`, `vite.config.ts`, `tsconfig.json`, `tailwind.config.ts`
- If these files are not present in your current directory, you are in the WRONG directory

### PowerShell Syntax (Windows Environment)
- **CRITICAL: Use semicolon (`;`) to chain commands, NEVER use `&&` (bash syntax that doesn't work in PowerShell)**

  ‚ùå **WRONG** (bash syntax):
  ```bash
  cd "C:\path\to\project" && npm run build
  ```

  ‚úÖ **CORRECT** (PowerShell syntax):
  ```powershell
  cd "C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder"; npm run build
  ```

  ‚úÖ **BETTER** (separate commands with explicit verification):
  ```powershell
  # First command: Navigate to project root
  cd "C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder"

  # Second command (in next tool call): Verify location, then run build
  pwd; npm run build
  ```

- Use PowerShell cmdlets and operators (e.g., `Get-ChildItem`, `Select-Object`, `-eq`, `-and`)
- For cross-platform npm scripts, use npm/npx commands which work consistently across shells
- When suggesting file operations, use PowerShell equivalents: `Remove-Item` instead of `rm`, `Copy-Item` instead of `cp`, etc.
- PowerShell uses `-and`, `-or`, `-not` for logical operators (not `&&`, `||`, `!`)

### Development Server Management
- **ALWAYS check if the development server is already running before executing `npm run dev`**
- Use PowerShell to check if a process is listening on port 5173 (Vite's default port):
  ```powershell
  # Check if port 5173 is in use
  Get-NetTCPConnection -LocalPort 5173 -State Listen -ErrorAction SilentlyContinue
  ```
- If the port is in use, inform the user that the dev server is already running
- Only execute `npm run dev` if the check confirms no server is running on that port
- **Example workflow:**
  ```powershell
  # First: Check if dev server is already running
  $devServer = Get-NetTCPConnection -LocalPort 5173 -State Listen -ErrorAction SilentlyContinue

  # If $devServer is null/empty, the port is free and we can start the server
  # If $devServer has a value, inform user the server is already running
  ```

### Examples of Correct Command Sequences

‚úÖ **Starting a new conversation:**
```powershell
# First: Check where we are
pwd
```
If output shows `C:\Users\Nipply Nathan\`, then:
```powershell
# Navigate to project root
cd "C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder"
```
Then in next command:
```powershell
# Now run the actual command
npm install
```

‚úÖ **Running tests:**
```powershell
# Verify location first, then run tests
cd "C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder"; npm test
```

‚úÖ **Starting the development server:**
```powershell
# First: Check if dev server is already running
Get-NetTCPConnection -LocalPort 5173 -State Listen -ErrorAction SilentlyContinue
```
If output is empty, then:
```powershell
# Navigate to project root and start dev server
cd "C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder"; npm run dev
```
If output shows a connection, inform the user: "Development server is already running on port 5173."

‚ùå **NEVER do this:**
```powershell
# Running project commands from home directory - WRONG!
npm run dev  # This will fail or run the wrong project

# Starting dev server without checking if it's already running - WRONG!
npm run dev  # Might cause port conflict errors
```

## When Suggesting Code
1. Always consider privacy and security implications
2. Verify TypeScript types are correct and specific
3. Ensure accessibility requirements are met
4. Include relevant tests
5. Follow existing code patterns and file organization
6. Check that solution works offline
7. Avoid introducing new dependencies unless necessary

## Device-to-Device Sync
- Sync features must use local Wi-Fi Direct or peer-to-peer connections only
- Use CouchDB replication protocol for RxDB sync
- No intermediary servers or hosted solutions
- Document sync setup for field deployment scenarios


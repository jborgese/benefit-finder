# BenefitFinder - Cursor AI Rules

## âš ï¸ COMMAND EXECUTION - READ THIS FIRST âš ï¸
ðŸš¨ **STOP! Before running ANY command, you MUST read and follow this section** ðŸš¨

### THE FUNDAMENTAL RULES
1. **NEVER execute npm, node, vite, vitest, playwright, or ANY project command without first navigating to:**
   ```
   C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder
   ```

2. **NEVER run `npm run dev` without checking if a development server is already running!**
   - Always check ports 5173-5179 first using `Get-NetTCPConnection`
   - Starting multiple dev servers creates conflicts and wastes resources
   - See "Development Server Management" section below for detailed instructions

### CRITICAL: Auto-Ran Command Blocks
ðŸš¨ **"Auto-Ran" commands create FRESH shell instances that start from the home directory!** ðŸš¨

**NEVER use "Auto-Ran" for project commands.** Instead, use the `run_terminal_cmd` tool which maintains shell state.

âŒ **WRONG - Auto-Ran creates fresh shell:**
```
Auto-Ran command: npm run dev
```
This will ALWAYS fail because it starts from `C:\Users\Nipply Nathan\` (no package.json).

âœ… **CORRECT - Use run_terminal_cmd:**
```powershell
cd "C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder"; npm run dev
```

### MANDATORY Pre-Command Workflow
Every single time you need to run a command, follow this exact sequence:

**Step 1:** Navigate to project root (ALWAYS do this first)
```powershell
cd "C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder"
```

**Step 2:** Verify you're in the correct location
```powershell
Test-Path package.json
```
This MUST return `True`. If it returns `False`, STOP - you're in the wrong directory.

**Step 3:** Only NOW can you run your actual command
```powershell
npm run dev
```

### Why This Matters
If you run `npm run dev` from `C:\Users\Nipply Nathan\` (the home directory), you will get:
```
npm error code ENOENT
npm error path C:\Users\Nipply Nathan\package.json
npm error Could not read package.json
```
This is the MOST COMMON FAILURE MODE for agents. Don't let this happen.

### PowerShell Syntax (Windows Environment)
- **Use semicolons (`;`) to chain commands, NEVER `&&`**

  âŒ WRONG: `cd "path" && npm install`
  âœ… CORRECT: `cd "C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder"; npm install`

- PowerShell uses `-and`, `-or`, `-not` for logic (not `&&`, `||`, `!`)
- Use `Test-Path` instead of checking file existence with bash commands

### Development Server Management
ðŸš¨ **CRITICAL: Always check for existing servers before starting new ones!** ðŸš¨

**NEVER run `npm run dev` without first checking for existing development servers!**

Before running `npm run dev`, ALWAYS check if it's already running on common Vite ports:
```powershell
# Check for existing Vite dev servers on ports 5173-5179
Get-NetTCPConnection -LocalPort 5173,5174,5175,5176,5177,5178,5179 -State Listen -ErrorAction SilentlyContinue
```

**If ANY output is returned, a server is already running. DO NOT start another one!**

Instead, inform the user that a server is already running and provide the URL:
```powershell
# If server is found, tell user it's running
Write-Host "Development server is already running! Check: http://localhost:5173/"
```

### Complete Example: Starting Dev Server
```powershell
# Step 1: Navigate
cd "C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder"

# Step 2: Verify location
Test-Path package.json

# Step 3: Check if already running (check multiple ports)
$existingServer = Get-NetTCPConnection -LocalPort 5173,5174,5175,5176,5177,5178,5179 -State Listen -ErrorAction SilentlyContinue
if ($existingServer) {
    $port = $existingServer.LocalPort
    Write-Host "Development server is already running on port $port! Access it at: http://localhost:$port/"
    Write-Host "DO NOT start another instance - this will create conflicts and waste resources!"
} else {
    # Step 4: Start server (only if no existing server found)
    npm run dev
}
```

### Alternative: Check for Node.js Processes
If the port check doesn't work, you can also check for running Node.js processes:
```powershell
# Check for running Node processes that might be dev servers
Get-Process -Name "node" -ErrorAction SilentlyContinue | Where-Object { $_.MainWindowTitle -like "*vite*" -or $_.CommandLine -like "*vite*" }
```

### When Server Is Already Running
If you find an existing development server:
1. **DO NOT start another instance**
2. **Inform the user** with the existing server URL
3. **Provide the port number** where it's running
4. **Suggest alternatives** like:
   - Opening the existing server URL in browser
   - Killing the existing server if they want to restart it
   - Using the existing server for development

Example response when server is found:
```powershell
Write-Host "âœ… Development server is already running on port $port!"
Write-Host "ðŸŒ Access your app at: http://localhost:$port/"
Write-Host "âš ï¸  Do NOT start another instance - this will create conflicts!"
Write-Host "ðŸ’¡ If you need to restart, first kill the existing server with the cleanup commands below."
```

### Port Cleanup (When Needed)
If you need to kill existing development servers:
```powershell
# Find processes on Vite ports
$processes = Get-NetTCPConnection -LocalPort 5173,5174,5175,5176,5177,5178,5179 -State Listen -ErrorAction SilentlyContinue | Select-Object -ExpandProperty OwningProcess | Sort-Object -Unique
if ($processes) {
    taskkill /F /PID ($processes -join " /PID ")
}
```

### Tool Usage Requirements
- **ALWAYS use `run_terminal_cmd` tool for project commands** - it maintains shell state
- **NEVER use "Auto-Ran" blocks for project commands** - they create fresh shells from home directory
- **Chain navigation and verification in single commands** when possible:
  ```powershell
  cd "C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder"; Test-Path package.json; npm run dev
  ```
- **If you must use separate commands, always include navigation in each one**

---

## Project Overview
BenefitFinder is a privacy-preserving, offline-first application for checking government benefits eligibility. All processing happens locally in the browser with no server dependencies.

## Core Principles
1. **Privacy First**: Never suggest solutions that send data to external servers or APIs
2. **Offline-First**: All features must work without internet connectivity
3. **Accessibility**: Follow WCAG 2.1 AA standards for all UI components
4. **Type Safety**: Strict TypeScript with no `any` types unless absolutely necessary
5. **Security**: Treat all user data as sensitive; use encryption for local storage
6. **Plain Language**: User-facing text should be clear and accessible to all reading levels

## Tech Stack Preferences

### Frontend
- React 18 with hooks (functional components only)
- TypeScript with strict mode enabled
- Tailwind CSS for styling (utility-first approach)
- Radix UI for accessible component primitives (always prefer over custom implementations)

### State & Data
- Zustand for global state management
- RxDB for reactive offline database operations
- Dexie for IndexedDB interactions
- Zod for runtime schema validation and type inference

### Logic & Visualization
- json-logic-js for rule evaluation (no custom rule engines)
- ReactFlow for visual flow diagrams
- Argdown for argument mapping

### Testing
- Vitest for unit tests (write tests for all new features)
- Playwright for E2E tests
- @axe-core/playwright for accessibility testing (required for UI changes)

## Code Standards

### TypeScript
- Use strict mode settings from tsconfig.json
- Prefer explicit return types for functions
- Use Zod schemas for runtime validation, derive TypeScript types from schemas
- No `any` types without explicit justification in comments
- Use discriminated unions for variant data types

### React
- Functional components only (no class components)
- Use custom hooks to extract reusable logic
- Prefer composition over prop drilling (use Zustand for shared state)
- Keep components focused and single-purpose
- Use React.memo() sparingly and only when performance issues are measured

### Styling
- Tailwind utility classes are preferred
- Use Tailwind config for theme customization (colors, spacing, etc.)
- Follow mobile-first responsive design principles
- Ensure minimum touch target size of 44x44px for interactive elements

### Accessibility
- All interactive elements must be keyboard accessible
- Use semantic HTML elements
- Include ARIA labels where semantic HTML is insufficient
- Ensure color contrast meets WCAG AA standards (4.5:1 for text)
- Test all UI changes with Playwright accessibility tests

### Security
- No external API calls or third-party services
- Use AES-GCM for encrypting sensitive data in local storage
- Sanitize any user-generated content with isomorphic-dompurify
- Validate all inputs with Zod schemas
- Never log sensitive user data

### Data & State
- Use RxDB for all persistent data storage
- Encrypt data at rest using built-in RxDB encryption
- Use Zustand for ephemeral UI state
- Keep state as close to where it's used as possible
- Use Immer for immutable state updates when needed

### Debug Logging
When a user requests debug logging to be added to a file:

1. **Check for Existing Helper**: Always search the file first for existing debug logging helper functions
   - Look for patterns like `debugLog`, `logDebug`, `debug`, or similar utilities
   - Check for existing debug configuration or constants (e.g., `DEBUG`, `VERBOSE`)

2. **Cognitive Complexity Management**:
   - **DO** create or use a helper function to centralize debug logic
   - **DON'T** add inline debug statements that increase cognitive complexity
   - Debug helpers should handle conditional logging, formatting, and context

3. **Helper Function Pattern**:
   ```typescript
   // Preferred pattern: Centralized debug helper
   const debugLog = (message: string, data?: unknown): void => {
     if (import.meta.env.DEV || localStorage.getItem('DEBUG_MODE')) {
       console.log(`[ComponentName] ${message}`, data ?? '');
     }
   };
   ```

4. **Revision Strategy**:
   - If a helper exists but doesn't meet the user's needs, revise it rather than creating a new one
   - Extend existing helpers with additional parameters or functionality
   - Maintain consistent debug patterns within the same file

5. **Best Practices**:
   - Include component/module name in debug messages for context
   - Use appropriate log levels (log, warn, error, debug)
   - Never log sensitive user data (see Security section)
   - Consider using a debug flag that can be toggled via localStorage or env var
   - Group related debug statements with `console.group()` when using a helper

6. **Example Implementation**:
   ```typescript
   // Helper function at top of file (after imports)
   const createDebugLogger = (moduleName: string) => ({
     log: (msg: string, data?: unknown) => {
       if (import.meta.env.DEV) console.log(`[${moduleName}] ${msg}`, data ?? '');
     },
     warn: (msg: string, data?: unknown) => {
       if (import.meta.env.DEV) console.warn(`[${moduleName}] ${msg}`, data ?? '');
     },
     error: (msg: string, data?: unknown) => {
       console.error(`[${moduleName}] ${msg}`, data ?? '');
     }
   });

   const debug = createDebugLogger('EligibilityEngine');

   // Usage in code
   debug.log('Evaluating rules', { ruleCount: rules.length });
   debug.warn('Missing required field', { field: 'income' });
   ```

7. **When to Skip Helpers**:
   - Single debug statement in entire file (use inline)
   - Temporary debugging during development (with TODO comment to remove)
   - Error boundaries or critical error logging (always keep these simple)

## Prohibited Patterns
- âŒ No hosted servers or cloud services
- âŒ No external API calls (except for optional device-to-device sync over local Wi-Fi)
- âŒ No analytics, tracking, or telemetry
- âŒ No cookies or session storage for user data
- âŒ No class components
- âŒ No inline styles (use Tailwind)
- âŒ No `any` types without justification
- âŒ No mutations of state objects (use Immer or immutable patterns)
- âŒ No accessibility bypasses or hacks

## File Organization
```
src/
â”œâ”€â”€ components/       # Reusable UI components
â”œâ”€â”€ features/        # Feature-specific modules
â”œâ”€â”€ hooks/           # Custom React hooks
â”œâ”€â”€ stores/          # Zustand stores
â”œâ”€â”€ db/              # RxDB schemas and collections
â”œâ”€â”€ rules/           # Benefit eligibility rules (JSON)
â”œâ”€â”€ types/           # TypeScript type definitions
â”œâ”€â”€ utils/           # Pure utility functions
â””â”€â”€ __tests__/       # Component and unit tests
```

## Testing Requirements
- All new features require unit tests
- UI changes require E2E tests with Playwright
- Accessibility tests required for interactive components
- Test coverage should trend upward (no reduction without justification)
- Use testing-library queries in priority order: role > label > test-id

## Documentation
- Add JSDoc comments for exported functions and types
- Include usage examples for complex utilities or hooks
- Update README.md for significant feature additions
- Document eligibility rule schemas and examples
- **All standalone documentation markdown files must be placed in `./docs/` or relevant subdirectories within `./docs/`**
  - Examples: `./docs/ENCRYPTION.md`, `./docs/SECURITY.md`, `./docs/RULE_SCHEMA.md`
  - Organize by topic: use subdirectories for feature-specific documentation if needed
  - Never create documentation files in the project root (except README.md)

## Git Workflow
- Use conventional commit format: `type(scope): description`
- Types: feat, fix, docs, style, refactor, test, chore
- Run `npm run lint` before committing
- Ensure tests pass before pushing

## When Suggesting Code
1. Always consider privacy and security implications
2. Verify TypeScript types are correct and specific
3. Ensure accessibility requirements are met
4. Include relevant tests
5. Follow existing code patterns and file organization
6. Check that solution works offline
7. Avoid introducing new dependencies unless necessary

## Device-to-Device Sync
- Sync features must use local Wi-Fi Direct or peer-to-peer connections only
- Use CouchDB replication protocol for RxDB sync
- No intermediary servers or hosted solutions
- Document sync setup for field deployment scenarios


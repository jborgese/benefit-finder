# BenefitFinder - Cursor AI Rules

## ‚ö†Ô∏è COMMAND EXECUTION - READ THIS FIRST ‚ö†Ô∏è
üö® **STOP! Before running ANY command, you MUST read and follow this section** üö®

### THE FUNDAMENTAL RULES
1. **NEVER execute npm, node, vite, vitest, playwright, or ANY project command without first navigating to:**
   ```
   C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder
   ```

2. **NEVER run `npm run dev` without checking if a development server is already running!**
   - Always check ports 5173-5179 first using `Get-NetTCPConnection`
   - Starting multiple dev servers creates conflicts and wastes resources
   - See "Development Server Management" section below for detailed instructions

### CRITICAL: Auto-Ran Command Blocks
üö® **"Auto-Ran" commands create FRESH shell instances that start from the home directory!** üö®

**NEVER use "Auto-Ran" for project commands.** Instead, use the `run_terminal_cmd` tool which maintains shell state.

‚ùå **WRONG - Auto-Ran creates fresh shell:**
```
Auto-Ran command: npm run dev
```
This will ALWAYS fail because it starts from `C:\Users\Nipply Nathan\` (no package.json).

‚úÖ **CORRECT - Use run_terminal_cmd:**
```powershell
cd "C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder"; npm run dev
```

### MANDATORY Pre-Command Workflow
Every single time you need to run a command, follow this exact sequence:

**Step 1:** Navigate to project root (ALWAYS do this first)
```powershell
cd "C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder"
```

**Step 2:** Verify you're in the correct location
```powershell
Test-Path package.json
```
This MUST return `True`. If it returns `False`, STOP - you're in the wrong directory.

**Step 3:** Only NOW can you run your actual command
```powershell
npm run dev
```

### Why This Matters
If you run `npm run dev` from `C:\Users\Nipply Nathan\` (the home directory), you will get:
```
npm error code ENOENT
npm error path C:\Users\Nipply Nathan\package.json
npm error Could not read package.json
```
This is the MOST COMMON FAILURE MODE for agents. Don't let this happen.

### PowerShell Syntax (Windows Environment)
- **Use semicolons (`;`) to chain commands, NEVER `&&`**

  ‚ùå WRONG: `cd "path" && npm install`
  ‚úÖ CORRECT: `cd "C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder"; npm install`

- PowerShell uses `-and`, `-or`, `-not` for logic (not `&&`, `||`, `!`)
- Use `Test-Path` instead of checking file existence with bash commands

### Development Server Management
üö® **CRITICAL: Always check for existing servers before starting new ones!** üö®

**NEVER run `npm run dev` without first checking for existing development servers!**

Before running `npm run dev`, ALWAYS check if it's already running on common Vite ports:
```powershell
# Check for existing Vite dev servers on ports 5173-5179
Get-NetTCPConnection -LocalPort 5173,5174,5175,5176,5177,5178,5179 -State Listen -ErrorAction SilentlyContinue
```

**If ANY output is returned, a server is already running. DO NOT start another one!**

Instead, inform the user that a server is already running and provide the URL:
```powershell
# If server is found, tell user it's running
Write-Host "Development server is already running! Check: http://localhost:5173/"
```

### Complete Example: Starting Dev Server
```powershell
# Step 1: Navigate
cd "C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder"

# Step 2: Verify location
Test-Path package.json

# Step 3: Check if already running (check multiple ports)
$existingServer = Get-NetTCPConnection -LocalPort 5173,5174,5175,5176,5177,5178,5179 -State Listen -ErrorAction SilentlyContinue
if ($existingServer) {
    $port = $existingServer.LocalPort
    Write-Host "Development server is already running on port $port! Access it at: http://localhost:$port/"
    Write-Host "DO NOT start another instance - this will create conflicts and waste resources!"
} else {
    # Step 4: Start server (only if no existing server found)
    npm run dev
}
```

### Alternative: Check for Node.js Processes
If the port check doesn't work, you can also check for running Node.js processes:
```powershell
# Check for running Node processes that might be dev servers
Get-Process -Name "node" -ErrorAction SilentlyContinue | Where-Object { $_.MainWindowTitle -like "*vite*" -or $_.CommandLine -like "*vite*" }
```

### When Server Is Already Running
If you find an existing development server:
1. **DO NOT start another instance**
2. **Inform the user** with the existing server URL
3. **Provide the port number** where it's running
4. **Suggest alternatives** like:
   - Opening the existing server URL in browser
   - Killing the existing server if they want to restart it
   - Using the existing server for development

Example response when server is found:
```powershell
Write-Host "‚úÖ Development server is already running on port $port!"
Write-Host "üåê Access your app at: http://localhost:$port/"
Write-Host "‚ö†Ô∏è  Do NOT start another instance - this will create conflicts!"
Write-Host "üí° If you need to restart, first kill the existing server with the cleanup commands below."
```

### Port Cleanup (When Needed)
If you need to kill existing development servers:
```powershell
# Find processes on Vite ports
$processes = Get-NetTCPConnection -LocalPort 5173,5174,5175,5176,5177,5178,5179 -State Listen -ErrorAction SilentlyContinue | Select-Object -ExpandProperty OwningProcess | Sort-Object -Unique
if ($processes) {
    taskkill /F /PID ($processes -join " /PID ")
}
```

### Tool Usage Requirements
- **ALWAYS use `run_terminal_cmd` tool for project commands** - it maintains shell state
- **NEVER use "Auto-Ran" blocks for project commands** - they create fresh shells from home directory
- **Chain navigation and verification in single commands** when possible:
  ```powershell
  cd "C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder"; Test-Path package.json; npm run dev
  ```
- **If you must use separate commands, always include navigation in each one**

---

## Project Overview
BenefitFinder is a privacy-preserving, offline-first application for checking government benefits eligibility. All processing happens locally in the browser with no server dependencies.

## Core Principles
1. **Privacy First**: Never suggest solutions that send data to external servers or APIs
2. **Offline-First**: All features must work without internet connectivity
3. **Accessibility**: Follow WCAG 2.1 AA standards for all UI components
4. **Type Safety**: Strict TypeScript with no `any` types unless absolutely necessary
5. **Security**: Treat all user data as sensitive; use encryption for local storage
6. **Plain Language**: User-facing text should be clear and accessible to all reading levels

## Tech Stack Preferences

### Frontend
- React 18 with hooks (functional components only)
- TypeScript with strict mode enabled
- Tailwind CSS for styling (utility-first approach)
- Radix UI for accessible component primitives (always prefer over custom implementations)

### State & Data
- Zustand for global state management
- RxDB for reactive offline database operations
- Dexie for IndexedDB interactions
- Zod for runtime schema validation and type inference

### Logic & Visualization
- json-logic-js for rule evaluation (no custom rule engines)
- ReactFlow for visual flow diagrams
- Argdown for argument mapping

### Testing
- Vitest for unit tests (write tests for all new features)
- Playwright for E2E tests
- @axe-core/playwright for accessibility testing (required for UI changes)

## Code Standards

### TypeScript
- Use strict mode settings from tsconfig.json
- Prefer explicit return types for functions
- Use Zod schemas for runtime validation, derive TypeScript types from schemas
- **NEVER use `any` types - always use specific, meaningful types**
- Use discriminated unions for variant data types

### Type Safety Rules - CRITICAL
üö® **NEVER generate code with `any` types. Always use specific types instead.**

**Prohibited Patterns:**
```typescript
// ‚ùå NEVER use these patterns
function processData(data: any) { ... }
const result: any = getValue();
const items: any[] = [];
const config: Record<string, any> = {};
```

**Required Alternatives:**
```typescript
// ‚úÖ ALWAYS use specific types
function processData(data: Record<string, unknown>) { ... }
function processData<T>(data: T) { ... }
const result: string | number = getValue();
const items: string[] = [];
const config: Record<string, unknown> = {};
```

**Type Alternatives to `any`:**
- `unknown` - for truly unknown data that needs type checking
- `Record<string, unknown>` - for objects with unknown structure
- `unknown[]` - for arrays of unknown items
- `string | number | boolean` - for primitive unions
- `SomeSpecificInterface` - for known object structures
- Generic types `<T>` - for reusable type-safe functions

**When generating code:**
1. **Always define specific types** for function parameters and return values
2. **Use interfaces or types** for object structures
3. **Prefer union types** over `any` for multiple possible types
4. **Use generic constraints** when you need flexibility with type safety
5. **Add JSDoc comments** explaining complex type relationships

**Example Type-Safe Patterns:**
```typescript
// ‚úÖ Good: Specific interface
interface UserData {
  id: string;
  name: string;
  email: string;
}

// ‚úÖ Good: Union type
type Status = 'loading' | 'success' | 'error';

// ‚úÖ Good: Generic with constraints
function processItems<T extends { id: string }>(items: T[]): T[] {
  return items.filter(item => item.id);
}

// ‚úÖ Good: Record with specific value types
const config: Record<string, string | number> = {};

// ‚úÖ Good: Optional properties
interface ApiResponse {
  data?: unknown;
  error?: string;
  status: number;
}
```

### React
- Functional components only (no class components)
- Use custom hooks to extract reusable logic
- Prefer composition over prop drilling (use Zustand for shared state)
- Keep components focused and single-purpose
- Use React.memo() sparingly and only when performance issues are measured

### Styling
- Tailwind utility classes are preferred
- Use Tailwind config for theme customization (colors, spacing, etc.)
- Follow mobile-first responsive design principles
- Ensure minimum touch target size of 44x44px for interactive elements

### Accessibility
- All interactive elements must be keyboard accessible
- Use semantic HTML elements
- Include ARIA labels where semantic HTML is insufficient
- Ensure color contrast meets WCAG AA standards (4.5:1 for text)
- Test all UI changes with Playwright accessibility tests

### Security
- No external API calls or third-party services
- Use AES-GCM for encrypting sensitive data in local storage
- Sanitize any user-generated content with isomorphic-dompurify
- Validate all inputs with Zod schemas
- Never log sensitive user data

### Data & State
- Use RxDB for all persistent data storage
- Encrypt data at rest using built-in RxDB encryption
- Use Zustand for ephemeral UI state
- Keep state as close to where it's used as possible
- Use Immer for immutable state updates when needed

### Debug Logging
When a user requests debug logging to be added to a file:

1. **Check for Existing Helper**: Always search the file first for existing debug logging helper functions
   - Look for patterns like `debugLog`, `logDebug`, `debug`, or similar utilities
   - Check for existing debug configuration or constants (e.g., `DEBUG`, `VERBOSE`)

2. **Cognitive Complexity Management**:
   - **DO** create or use a helper function to centralize debug logic
   - **DON'T** add inline debug statements that increase cognitive complexity
   - Debug helpers should handle conditional logging, formatting, and context

3. **Helper Function Pattern**:
   ```typescript
   // Preferred pattern: Centralized debug helper
   const debugLog = (message: string, data?: unknown): void => {
     if (import.meta.env.DEV || localStorage.getItem('DEBUG_MODE')) {
       console.log(`[ComponentName] ${message}`, data ?? '');
     }
   };
   ```

4. **Revision Strategy**:
   - If a helper exists but doesn't meet the user's needs, revise it rather than creating a new one
   - Extend existing helpers with additional parameters or functionality
   - Maintain consistent debug patterns within the same file

5. **Best Practices**:
   - Include component/module name in debug messages for context
   - Use appropriate log levels (log, warn, error, debug)
   - Never log sensitive user data (see Security section)
   - Consider using a debug flag that can be toggled via localStorage or env var
   - Group related debug statements with `console.group()` when using a helper

6. **Example Implementation**:
   ```typescript
   // Helper function at top of file (after imports)
   const createDebugLogger = (moduleName: string) => ({
     log: (msg: string, data?: unknown) => {
       if (import.meta.env.DEV) console.log(`[${moduleName}] ${msg}`, data ?? '');
     },
     warn: (msg: string, data?: unknown) => {
       if (import.meta.env.DEV) console.warn(`[${moduleName}] ${msg}`, data ?? '');
     },
     error: (msg: string, data?: unknown) => {
       console.error(`[${moduleName}] ${msg}`, data ?? '');
     }
   });

   const debug = createDebugLogger('EligibilityEngine');

   // Usage in code
   debug.log('Evaluating rules', { ruleCount: rules.length });
   debug.warn('Missing required field', { field: 'income' });
   ```

7. **When to Skip Helpers**:
   - Single debug statement in entire file (use inline)
   - Temporary debugging during development (with TODO comment to remove)
   - Error boundaries or critical error logging (always keep these simple)

## Prohibited Patterns
- ‚ùå No hosted servers or cloud services
- ‚ùå No external API calls (except for optional device-to-device sync over local Wi-Fi)
- ‚ùå No analytics, tracking, or telemetry
- ‚ùå No cookies or session storage for user data
- ‚ùå No class components
- ‚ùå No inline styles (use Tailwind)
- ‚ùå No `any` types without justification
- ‚ùå No mutations of state objects (use Immer or immutable patterns)
- ‚ùå No accessibility bypasses or hacks

## File Organization
```
src/
‚îú‚îÄ‚îÄ components/       # Reusable UI components
‚îú‚îÄ‚îÄ features/        # Feature-specific modules
‚îú‚îÄ‚îÄ hooks/           # Custom React hooks
‚îú‚îÄ‚îÄ stores/          # Zustand stores
‚îú‚îÄ‚îÄ db/              # RxDB schemas and collections
‚îú‚îÄ‚îÄ rules/           # Benefit eligibility rules (JSON)
‚îú‚îÄ‚îÄ types/           # TypeScript type definitions
‚îú‚îÄ‚îÄ utils/           # Pure utility functions
‚îî‚îÄ‚îÄ __tests__/       # Component and unit tests
```

## Testing Requirements
- All new features require unit tests
- UI changes require E2E tests with Playwright
- Accessibility tests required for interactive components
- Test coverage should trend upward (no reduction without justification)
- Use testing-library queries in priority order: role > label > test-id

## Documentation
- Add JSDoc comments for exported functions and types
- Include usage examples for complex utilities or hooks
- Update README.md for significant feature additions
- Document eligibility rule schemas and examples
- **All standalone documentation markdown files must be placed in `./docs/` or relevant subdirectories within `./docs/`**
  - Examples: `./docs/ENCRYPTION.md`, `./docs/SECURITY.md`, `./docs/RULE_SCHEMA.md`
  - Organize by topic: use subdirectories for feature-specific documentation if needed
  - Never create documentation files in the project root (except README.md)

## Post-File Creation Linting Requirements
üö® **MANDATORY: Run linting after creating ANY new file** üö®

### When This Rule Applies
This rule applies when you create ANY new file, including but not limited to:
- Test files (`*.test.ts`, `*.test.tsx`, `*.spec.ts`, `*.spec.tsx`)
- Component files (`*.tsx`)
- Utility files (`*.ts`)
- Configuration files (`*.json`, `*.js`, `*.ts`)
- Documentation files (`*.md`)
- Any other file that could be linted

### Required Workflow After File Creation
**Step 1:** Navigate to project root (ALWAYS do this first)
```powershell
cd "C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder"
```

**Step 2:** Verify you're in the correct location
```powershell
Test-Path package.json
```

**Step 3:** Run linting on the newly created file
```powershell
npm run lint -- "path/to/newly/created/file"
```

**Step 4:** If linting errors/warnings are found, fix them immediately
```powershell
npm run lint:fix -- "path/to/newly/created/file"
```

**Step 5:** Re-run linting to verify all issues are resolved
```powershell
npm run lint -- "path/to/newly/created/file"
```

### Complete Example: After Creating a Test File
```powershell
# After creating src/components/Button.test.tsx
cd "C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder"
Test-Path package.json
npm run lint -- "src/components/Button.test.tsx"
# If errors found:
npm run lint:fix -- "src/components/Button.test.tsx"
npm run lint -- "src/components/Button.test.tsx"  # Verify fixes
```

### Linting Error Resolution Guidelines
1. **Auto-fixable issues**: Use `npm run lint:fix` to automatically resolve formatting and simple issues
2. **Type errors**: Fix TypeScript type issues manually - never use `any` types
3. **Import/export issues**: Ensure proper imports and exports according to project standards
4. **Accessibility issues**: Fix any accessibility-related linting warnings
5. **Security warnings**: Address any security-related linting warnings
6. **Unused variables**: Remove or properly use all declared variables

### What Constitutes "Resolved"
- ‚úÖ **Zero linting errors** for the newly created file
- ‚úÖ **Zero linting warnings** for the newly created file (unless explicitly justified)
- ‚úÖ **File passes all ESLint rules** configured in the project
- ‚úÖ **TypeScript compilation succeeds** without errors

### Failure to Comply
If you create a file and do NOT run linting:
- ‚ùå **You have NOT completed the task**
- ‚ùå **The file may contain errors that break the build**
- ‚ùå **The file may not follow project coding standards**
- ‚ùå **You must go back and fix the linting issues before wrapping up**

### Integration with Existing Workflow
This rule works in conjunction with the existing Git workflow:
1. Create file ‚Üí Run linting (this rule)
2. Fix any linting issues
3. Run tests if applicable
4. Commit with proper message
5. Push to repository

## Git Workflow
- Use conventional commit format: `type(scope): description`
- Types: feat, fix, docs, style, refactor, test, chore
- Run `npm run lint` before committing
- Ensure tests pass before pushing

## When Suggesting Code
1. Always consider privacy and security implications
2. Verify TypeScript types are correct and specific
3. Ensure accessibility requirements are met
4. Include relevant tests
5. Follow existing code patterns and file organization
6. Check that solution works offline
7. Avoid introducing new dependencies unless necessary

## Device-to-Device Sync
- Sync features must use local Wi-Fi Direct or peer-to-peer connections only
- Use CouchDB replication protocol for RxDB sync
- No intermediary servers or hosted solutions
- Document sync setup for field deployment scenarios


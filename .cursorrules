# BenefitFinder - Cursor AI Rules

## ⚠️ COMMAND EXECUTION - READ THIS FIRST ⚠️
🚨 **STOP! Before running ANY command, you MUST read and follow this section** 🚨

### THE FUNDAMENTAL RULE
**NEVER execute npm, node, vite, vitest, playwright, or ANY project command without first navigating to:**
```
C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder
```

### CRITICAL: Auto-Ran Command Blocks
🚨 **"Auto-Ran" commands create FRESH shell instances that start from the home directory!** 🚨

**NEVER use "Auto-Ran" for project commands.** Instead, use the `run_terminal_cmd` tool which maintains shell state.

❌ **WRONG - Auto-Ran creates fresh shell:**
```
Auto-Ran command: npm run dev
```
This will ALWAYS fail because it starts from `C:\Users\Nipply Nathan\` (no package.json).

✅ **CORRECT - Use run_terminal_cmd:**
```powershell
cd "C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder"; npm run dev
```

### MANDATORY Pre-Command Workflow
Every single time you need to run a command, follow this exact sequence:

**Step 1:** Navigate to project root (ALWAYS do this first)
```powershell
cd "C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder"
```

**Step 2:** Verify you're in the correct location
```powershell
Test-Path package.json
```
This MUST return `True`. If it returns `False`, STOP - you're in the wrong directory.

**Step 3:** Only NOW can you run your actual command
```powershell
npm run dev
```

### Why This Matters
If you run `npm run dev` from `C:\Users\Nipply Nathan\` (the home directory), you will get:
```
npm error code ENOENT
npm error path C:\Users\Nipply Nathan\package.json
npm error Could not read package.json
```
This is the MOST COMMON FAILURE MODE for agents. Don't let this happen.

### PowerShell Syntax (Windows Environment)
- **Use semicolons (`;`) to chain commands, NEVER `&&`**

  ❌ WRONG: `cd "path" && npm install`
  ✅ CORRECT: `cd "C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder"; npm install`

- PowerShell uses `-and`, `-or`, `-not` for logic (not `&&`, `||`, `!`)
- Use `Test-Path` instead of checking file existence with bash commands

### Development Server Management
Before running `npm run dev`, ALWAYS check if it's already running:
```powershell
Get-NetTCPConnection -LocalPort 5173 -State Listen -ErrorAction SilentlyContinue
```
If this returns any output, the server is already running. Don't start another one.

### Complete Example: Starting Dev Server
```powershell
# Step 1: Navigate
cd "C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder"

# Step 2: Verify location
Test-Path package.json

# Step 3: Check if already running
Get-NetTCPConnection -LocalPort 5173 -State Listen -ErrorAction SilentlyContinue

# Step 4: Start server (only if port check was empty)
npm run dev
```

### Tool Usage Requirements
- **ALWAYS use `run_terminal_cmd` tool for project commands** - it maintains shell state
- **NEVER use "Auto-Ran" blocks for project commands** - they create fresh shells from home directory
- **Chain navigation and verification in single commands** when possible:
  ```powershell
  cd "C:\Users\Nipply Nathan\Documents\GitHub\benefit-finder"; Test-Path package.json; npm run dev
  ```
- **If you must use separate commands, always include navigation in each one**

---

## Project Overview
BenefitFinder is a privacy-preserving, offline-first application for checking government benefits eligibility. All processing happens locally in the browser with no server dependencies.

## Core Principles
1. **Privacy First**: Never suggest solutions that send data to external servers or APIs
2. **Offline-First**: All features must work without internet connectivity
3. **Accessibility**: Follow WCAG 2.1 AA standards for all UI components
4. **Type Safety**: Strict TypeScript with no `any` types unless absolutely necessary
5. **Security**: Treat all user data as sensitive; use encryption for local storage
6. **Plain Language**: User-facing text should be clear and accessible to all reading levels

## Tech Stack Preferences

### Frontend
- React 18 with hooks (functional components only)
- TypeScript with strict mode enabled
- Tailwind CSS for styling (utility-first approach)
- Radix UI for accessible component primitives (always prefer over custom implementations)

### State & Data
- Zustand for global state management
- RxDB for reactive offline database operations
- Dexie for IndexedDB interactions
- Zod for runtime schema validation and type inference

### Logic & Visualization
- json-logic-js for rule evaluation (no custom rule engines)
- ReactFlow for visual flow diagrams
- Argdown for argument mapping

### Testing
- Vitest for unit tests (write tests for all new features)
- Playwright for E2E tests
- @axe-core/playwright for accessibility testing (required for UI changes)

## Code Standards

### TypeScript
- Use strict mode settings from tsconfig.json
- Prefer explicit return types for functions
- Use Zod schemas for runtime validation, derive TypeScript types from schemas
- No `any` types without explicit justification in comments
- Use discriminated unions for variant data types

### React
- Functional components only (no class components)
- Use custom hooks to extract reusable logic
- Prefer composition over prop drilling (use Zustand for shared state)
- Keep components focused and single-purpose
- Use React.memo() sparingly and only when performance issues are measured

### Styling
- Tailwind utility classes are preferred
- Use Tailwind config for theme customization (colors, spacing, etc.)
- Follow mobile-first responsive design principles
- Ensure minimum touch target size of 44x44px for interactive elements

### Accessibility
- All interactive elements must be keyboard accessible
- Use semantic HTML elements
- Include ARIA labels where semantic HTML is insufficient
- Ensure color contrast meets WCAG AA standards (4.5:1 for text)
- Test all UI changes with Playwright accessibility tests

### Security
- No external API calls or third-party services
- Use AES-GCM for encrypting sensitive data in local storage
- Sanitize any user-generated content with isomorphic-dompurify
- Validate all inputs with Zod schemas
- Never log sensitive user data

### Data & State
- Use RxDB for all persistent data storage
- Encrypt data at rest using built-in RxDB encryption
- Use Zustand for ephemeral UI state
- Keep state as close to where it's used as possible
- Use Immer for immutable state updates when needed

## Prohibited Patterns
- ❌ No hosted servers or cloud services
- ❌ No external API calls (except for optional device-to-device sync over local Wi-Fi)
- ❌ No analytics, tracking, or telemetry
- ❌ No cookies or session storage for user data
- ❌ No class components
- ❌ No inline styles (use Tailwind)
- ❌ No `any` types without justification
- ❌ No mutations of state objects (use Immer or immutable patterns)
- ❌ No accessibility bypasses or hacks

## File Organization
```
src/
├── components/       # Reusable UI components
├── features/        # Feature-specific modules
├── hooks/           # Custom React hooks
├── stores/          # Zustand stores
├── db/              # RxDB schemas and collections
├── rules/           # Benefit eligibility rules (JSON)
├── types/           # TypeScript type definitions
├── utils/           # Pure utility functions
└── __tests__/       # Component and unit tests
```

## Testing Requirements
- All new features require unit tests
- UI changes require E2E tests with Playwright
- Accessibility tests required for interactive components
- Test coverage should trend upward (no reduction without justification)
- Use testing-library queries in priority order: role > label > test-id

## Documentation
- Add JSDoc comments for exported functions and types
- Include usage examples for complex utilities or hooks
- Update README.md for significant feature additions
- Document eligibility rule schemas and examples
- **All standalone documentation markdown files must be placed in `./docs/` or relevant subdirectories within `./docs/`**
  - Examples: `./docs/ENCRYPTION.md`, `./docs/SECURITY.md`, `./docs/RULE_SCHEMA.md`
  - Organize by topic: use subdirectories for feature-specific documentation if needed
  - Never create documentation files in the project root (except README.md)

## Git Workflow
- Use conventional commit format: `type(scope): description`
- Types: feat, fix, docs, style, refactor, test, chore
- Run `npm run lint` before committing
- Ensure tests pass before pushing

## When Suggesting Code
1. Always consider privacy and security implications
2. Verify TypeScript types are correct and specific
3. Ensure accessibility requirements are met
4. Include relevant tests
5. Follow existing code patterns and file organization
6. Check that solution works offline
7. Avoid introducing new dependencies unless necessary

## Device-to-Device Sync
- Sync features must use local Wi-Fi Direct or peer-to-peer connections only
- Use CouchDB replication protocol for RxDB sync
- No intermediary servers or hosted solutions
- Document sync setup for field deployment scenarios

